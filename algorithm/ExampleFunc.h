//
//  ExampleFunc.h
//  algorithm
//
//  Created by shiwei on 2018/12/26.
//

#ifndef ExampleFunc_h
#define ExampleFunc_h

///这里保存一些具有启发意义的方法

//因为是离散的，会出错：{1, 2, 1, 3, 4, 5, 5, 4}.其实4-5-5-4之间是有一个峰值的，但是离散的看不出来，或说没有一个绝对的峰值点，两个5都是峰值。  *** 相邻数字不同的条件下才正确 ***

//这题的二分法条件是:左侧是递增的，右侧是递减的，那么峰值必定在中间。
/*
 这题对于使用二分法有启发作用：首先二分法的核心在于将大问题化为小问题，而这个“大”与“小”具体就是问题的规模,在数组问题上就是考察的范围。
 二分法在于把原范围切割成两部分，然后可以确定解在其中一个范围内，这样问题规模就缩小了。
 而这题的启发在于：因为一些条件，确定解在当前范围内，变化的手段在于，把这个条件转移到子区间里。这样想的好处是可以考虑：是什么条件，让我们确定解在一个范围内。如果找到这样的条件，那么就可以方便的找到转移的方法，也就可以找到过渡的方法。
 更具体些，过程中是这样的：对于考察范围，左侧是情况1.右侧是情况2，内部是未知情况。切割区间时，是：
      1. 把左区间变成情况1，这样考察范围缩小到右区间
      2. 把右区间变成情况2，考察范围缩小到左区间
 总结来说，要找到夹逼的条件。这里就是这样，二分查找也是这样。
 */
int findPeak(vector<int>& A) {
    
    int i = 0, j = (int)A.size()-1;
    while (i < j-2) { //临界条件是中间隔着2个数
        int mid = i+(j-i)/2;
        
        if (A[mid+1]>A[mid]) {
            i = mid;
        }else{
            j = mid+1;
        }
    }
    
    return i+1;
}

#endif /* ExampleFunc_h */
