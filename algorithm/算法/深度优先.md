1. "16. 带重复元素的排列"这题具有递归和非递归版本，非递归版本体现深度优先的特性。
2. **深度优先搜索**可以理解为：某个时刻你有很多选择，做了这个选择之后，又有很多新的选择，只要还有选择，就一直选，直到没有选择或者得到需要的结果。在没有选择之后，退回到上一次选择的状态，继续尝试。
   **构成元素是选择和状态**，不仅仅是明显的树结构，很多问题都可以归类到**选择和状态的模型**里
3. 深度优先的关键是记得回退的路口，当没路可走后可以回到上一个路口选择新的路走下去。而**栈**的性质非常适合用来记住这些路口。

####关键点

1. 深度搜索关键在于回溯，而回溯就需要记住每个选择点，即岔路，的状态，该定义一个什么样的状态又是其中关键问题。
 这题里状态就是：当前的路径、已选的数标记和当前选到第几个数
2. 另一个关键点是：向前推进的行为和回溯后的行为要一致，这样才能统一成一个行为，即开始一个新的循环时，你不能区分它是新点还是回溯的旧点。一般就是把新店置为特殊状态的旧点，比如这题,新点就是挖掘0个子节点的点，而旧点就是>0的点，但它们的行为是一致的，就是从未选的数里选一个作为子节点。
3. 第三个关键点就是边界条件：1）什么时候得到完整的路径，即得到一个解 2）什么时候回溯。第一个是在路径最深的时候，指标可以是深度或者没有新的路径了；第二个是当前没有新的路径了，所以**当前选择到哪条路了**是必须的状态

####代码行为模式：

1. 一个循环
2. 在循环里，先做**推进尝试**，即查看现在有没有新的选择，有就可以跳转到下一个状态；
3. 如果没有选择或者达到目标，就退回到上一个状态。达到目标时，要把当前结果存入结果集。
4. 总结就是：从一个状态迁移到另一个状态

一般要维护的状态：

 * 当前的路径，即当前已经做了的选择的列表
 * 某个状态有多个选择，它选到了哪一个了
 * 目标的变化、可选性的变化，比如前面选了的数后面不能选

####例题

* 136. 分割回文串  不用“选择和状态”的角度去理解深度搜索，是无法把这题跟深度搜索联系起来的，但它其实还真的就是。